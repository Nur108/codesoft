<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unbeatable Tic-Tac-Toe (Minimax + Alpha-Beta)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#10b981;--muted:#94a3b8;--win:#f59e0b}
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#041023 0%, #071428 100%);color:#e6eef8}
    .container{width:min(720px,96vw);background:linear-gradient(180deg,rgba(255,255,255,.02),transparent);padding:20px;border-radius:14px;box-shadow:0 6px 30px rgba(2,6,23,.6)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer}
    .btn.primary{background:var(--accent);color:#04201a;border:none}
    .board-wrap{display:flex;gap:24px;align-items:center;margin-top:18px}
    .board{width:360px;height:360px;background:linear-gradient(180deg,#061529,#041224);display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:8px;padding:8px;border-radius:12px}
    .cell{display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.02);border-radius:8px;font-size:64px;cursor:pointer;user-select:none;transition:transform .12s ease, background .15s}
    .cell:hover{transform:translateY(-4px)}
    .meta{flex:1;display:flex;flex-direction:column;gap:12px}
    .status{padding:10px;border-radius:10px;background:rgba(255,255,255,.02);color:var(--muted)}
    .score{display:flex;gap:12px}
    .score .card{background:rgba(255,255,255,.02);padding:10px;border-radius:10px;min-width:110px;text-align:center}
    .small{font-size:12px;color:var(--muted)}
    .choice{display:flex;gap:8px}
    .line{height:4px;background:transparent;position:relative;margin-top:12px}
    .winner-line{position:absolute;height:4px;background:var(--win);border-radius:4px;opacity:0.95;transform-origin:left center}
    footer{display:flex;justify-content:space-between;align-items:center;margin-top:14px;font-size:13px;color:var(--muted)}
    @media (max-width:640px){.board{width:300px;height:300px}.cell{font-size:48px}}
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <h1>Unbeatable Tic‑Tac‑Toe (Minimax + Alpha‑Beta)</h1>
      <div class="controls">
        <button class="btn" id="newBtn">New Game</button>
        <button class="btn" id="swapBtn">Swap (You: X)</button>
      </div>
    </header>

    <div class="board-wrap">
      <div class="board" id="board" aria-label="Tic tac toe board">
        <!-- 9 cells injected by JS -->
      </div>

      <div class="meta">
        <div class="status" id="status">Your move — you play as <strong id="playerChar">X</strong></div>
        <div class="score">
          <div class="card"><div class="small">You</div><div id="humanScore">0</div></div>
          <div class="card"><div class="small">Ties</div><div id="ties">0</div></div>
          <div class="card"><div class="small">Computer</div><div id="aiScore">0</div></div>
        </div>

        <div class="line" id="lineWrap" aria-hidden="true"></div>

        <div class="small">Tips: The AI uses Minimax with alpha‑beta pruning so it's unbeatable. You can swap X/O or start a new game anytime.</div>
      </div>
    </div>

    <footer>
      <div>Made for learning — simple, clear, single file.</div>
      <div class="small">Save as <code>tictactoe.html</code> and open in a browser.</div>
    </footer>
  </div>

  <script>
    // Game state
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const playerCharEl = document.getElementById('playerChar');
    const newBtn = document.getElementById('newBtn');
    const swapBtn = document.getElementById('swapBtn');
    const humanScoreEl = document.getElementById('humanScore');
    const aiScoreEl = document.getElementById('aiScore');
    const tiesEl = document.getElementById('ties');
    const lineWrap = document.getElementById('lineWrap');

    let human = 'X';
    let ai = 'O';
    let board = Array(9).fill(null);
    let isHumanTurn = true;
    let scores = {human:0, ai:0, ties:0};

    const WIN_COMBOS = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];

    function init(){
      boardEl.innerHTML = '';
      board = Array(9).fill(null);
      lineWrap.innerHTML = '';

      for(let i=0;i<9;i++){
        const c = document.createElement('div');
        c.className = 'cell';
        c.dataset.index = i;
        c.addEventListener('click', onCellClicked);
        boardEl.appendChild(c);
      }

      playerCharEl.textContent = human;
      swapBtn.textContent = `Swap (You: ${human})`;

      if(!isHumanTurn){
        statusEl.textContent = "Computer's turn...";
        window.requestAnimationFrame(()=>{aiMove();});
      } else {
        statusEl.innerHTML = `Your move — you play as <strong>${human}</strong>`;
      }
    }

    function onCellClicked(e){
      const idx = Number(e.currentTarget.dataset.index);
      if(board[idx] || !isHumanTurn) return;

      makeMove(idx, human);
      updateBoard();

      const win = checkWinner(board);
      if(win){handleResult(win);return}

      isHumanTurn = false;
      statusEl.textContent = "Computer's turn...";
      setTimeout(()=>{aiMove()}, 300);
    }

    function makeMove(i, player){
      board[i] = player;
    }

    function updateBoard(){
      for(let i=0;i<9;i++){
        boardEl.children[i].textContent = board[i] || '';
      }
    }

    function checkWinner(bd){
      for(const combo of WIN_COMBOS){
        const [a,b,c] = combo;
        if(bd[a] && bd[a] === bd[b] && bd[a] === bd[c]){
          return {winner: bd[a], combo};
        }
      }
      if(bd.every(cell=>cell)) return {winner: 'tie'};
      return null;
    }

    function handleResult(result){
      if(result.winner === 'tie'){
        scores.ties++;
        tiesEl.textContent = scores.ties;
        statusEl.textContent = "It's a tie!";
      } else if(result.winner === human){
        scores.human++;
        humanScoreEl.textContent = scores.human;
        statusEl.textContent = 'You win — well played!';
        showLine(result.combo);
      } else {
        scores.ai++;
        aiScoreEl.textContent = scores.ai;
        statusEl.textContent = 'Computer wins — good try!';
        showLine(result.combo);
      }
      // freeze board
      isHumanTurn = false;
    }

    function showLine(combo){
      // Render a small horizontal line overlay approximating the winning line
      lineWrap.innerHTML = '';
      const line = document.createElement('div');
      line.className = 'winner-line';
      // compute position roughly
      const [a,b,c] = combo;
      const rows = [0,1,2];
      const cols = [0,1,2];
      const positions = combo.map(i=>({r:Math.floor(i/3), c:i%3}));
      const avgR = (positions[0].r + positions[2].r)/2;
      const avgC = (positions[0].c + positions[2].c)/2;
      const top = avgR * ( (boardEl.clientHeight - 16) / 3 ) + 8 + 20; // fudge factor
      const left = avgC * ( (boardEl.clientWidth - 16) / 3 ) + 8;

      // width and rotation
      let width = Math.hypot((positions[0].c - positions[2].c), (positions[0].r - positions[2].r));
      width = (Math.max(boardEl.clientWidth, boardEl.clientHeight) / 3) * (width || 1) + 40;
      const angle = Math.atan2(positions[2].r - positions[0].r, positions[2].c - positions[0].c) * 180/Math.PI;

      line.style.width = width + 'px';
      line.style.top = (top - 10) + 'px';
      line.style.left = (left - 20) + 'px';
      line.style.transform = `rotate(${angle}deg)`;

      lineWrap.appendChild(line);
    }

    // ----- Minimax with Alpha-Beta -----
    function aiMove(){
      const best = minimax(board.slice(), ai, -Infinity, +Infinity, 0);
      // best.index should be chosen
      if(best && typeof best.index === 'number'){
        makeMove(best.index, ai);
      } else {
        // fallback: choose first available
        const idx = board.findIndex(c=>!c);
        if(idx>=0) makeMove(idx, ai);
      }
      updateBoard();
      const win = checkWinner(board);
      if(win){handleResult(win);return}
      isHumanTurn = true;
      statusEl.innerHTML = `Your move — you play as <strong>${human}</strong>`;
    }

    // scores: ai win -> +10, human win -> -10, tie -> 0
    function evaluate(bd, depth){
      const res = checkWinner(bd);
      if(!res) return null;
      if(res.winner === ai) return 10 - depth;
      if(res.winner === human) return depth - 10;
      return 0;
    }

    function minimax(bd, player, alpha, beta, depth){
      const scoreEval = evaluate(bd, depth);
      if(scoreEval !== null) return {score: scoreEval};

      const avail = bd.map((v,i)=>v ? null : i).filter(x=>x!==null);

      if(player === ai){
        let best = {score: -Infinity, index: null};
        for(const i of avail){
          bd[i] = ai;
          const result = minimax(bd, human, alpha, beta, depth+1);
          bd[i] = null;
          if(result.score > best.score){ best = {score: result.score, index: i}; }
          alpha = Math.max(alpha, result.score);
          if(beta <= alpha) break; // prune
        }
        return best;
      } else {
        let best = {score: +Infinity, index: null};
        for(const i of avail){
          bd[i] = human;
          const result = minimax(bd, ai, alpha, beta, depth+1);
          bd[i] = null;
          if(result.score < best.score){ best = {score: result.score, index: i}; }
          beta = Math.min(beta, result.score);
          if(beta <= alpha) break;
        }
        return best;
      }
    }

    // UI controls
    newBtn.addEventListener('click', ()=>{ isHumanTurn = (human === 'X'); init(); });

    swapBtn.addEventListener('click', ()=>{
      // swap roles
      const oldHuman = human;
      human = (human === 'X') ? 'O' : 'X';
      ai = (human === 'X') ? 'O' : 'X';
      isHumanTurn = (human === 'X');
      swapBtn.textContent = `Swap (You: ${human})`;
      init();
    });

    // start
    isHumanTurn = true;
    init();
  </script>
</body>
</html>
